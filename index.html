<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì†Œë¦¬ ì í”„ ì¥ì• ë¬¼ ê²Œì„</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #fff;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
    }
    #gameCanvas {
      background: #333;
      border: 2px solid #555;
      margin-top: 10px;
    }
    #info {
      margin-top: 10px;
      text-align: center;
      font-size: 14px;
      line-height: 1.5;
    }
    button {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h2>ì†Œë¦¬ë¡œ ì í”„í•˜ëŠ” ì¥ì• ë¬¼ ê²Œì„ (ì´ë¯¸ì§€ ë²„ì „)</h2>
  <button id="startBtn">ë§ˆì´í¬ í—ˆìš© í›„ ê²Œì„ ì‹œì‘</button>
  <canvas id="gameCanvas" width="800" height="400"></canvas>

  <div id="info">
    ğŸ”Š ë§ˆì´í¬ì— ëŒ€ê³  ì†Œë¦¬ë¥¼ ë‚´ë©´ ì í”„í•©ë‹ˆë‹¤. (2ë‹¨ ì í”„ ê°€ëŠ¥!)<br>
    ìºë¦­í„°/ì¥ì• ë¬¼/ì½”ì¸ì€ íˆ¬ëª… ë°°ê²½ PNG ì´ë¯¸ì§€ë¡œ í‘œì‹œë©ë‹ˆë‹¤.<br>
    dB(ìƒëŒ€ê°’)ëŠ” ì‹¤ì œ ë¬¼ë¦¬ ë°ì‹œë²¨ì´ ì•„ë‹Œ, ê²Œì„ìš© í‘œì‹œê°’ì…ë‹ˆë‹¤.
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const startBtn = document.getElementById("startBtn");

    // --------- ì´ë¯¸ì§€ ë¡œë”© ---------
    const imgPlayer = new Image();
    const imgObstacle = new Image();
    const imgCoin = new Image();

    // â–¶ ì—¬ê¸° íŒŒì¼ ì´ë¦„ì„ ë„¤ê°€ ì €ì¥í•œ íŒŒì¼ëª…ìœ¼ë¡œ ë°”ê¿”ì¤˜
    imgPlayer.src   = "player.png";    // ì•µê·¸ë¦¬ë²„ë“œ ëŠë‚Œ ìºë¦­í„°
    imgObstacle.src = "obstacle.png";  // ê°€ì‹œ/ìƒì ë“±
    imgCoin.src     = "coin.png";      // ë…¸ë€ ì½”ì¸

    // ì˜¤ë””ì˜¤ ê´€ë ¨ ë³€ìˆ˜
    let audioContext, analyser, dataArray;
    let micReady = false;

    // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
    const groundY = 320; // ë°”ë‹¥ y (í”Œë ˆì´ì–´ ê¸°ì¤€)
    const gravity = 0.6;
    const obstacleSpeed = 4.5;

    let obstacles = [];
    let spawnTimer = 0;
    let spawnInterval = 1500; // ms

    let coins = [];
    let coinSpawnTimer = 0;
    let coinSpawnInterval = 1200; // ms

    let lastTime = 0;
    let gameRunning = false;
    let score = 0;
    let coinsCollected = 0;

    // ì í”„ ê´€ë ¨ ë³€ìˆ˜ (2ë‹¨ ì í”„)
    let jumpCount = 0;
    const maxJumpCount = 2;
    const jumpThreshold = 0.25;
    let wasOverThreshold = false;

    // ë³¼ë¥¨/ë°ì‹œë²¨ í‘œì‹œìš©
    let lastAvgAmp = 0;
    let lastDb = 0;
    let lastVolume = 0;

    const player = {
      x: 100,
      y: groundY,
      w: 48,  // ì´ë¯¸ì§€ í¬ê¸°ì— ë§ê²Œ ì‚´ì§ í‚¤ì›€
      h: 48,
      vy: 0
    };

    function initAudio(stream) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      const bufferLength = analyser.fftSize;
      dataArray = new Uint8Array(bufferLength);

      source.connect(analyser);
      micReady = true;
    }

    function getVolume() {
      if (!micReady) return 0;

      analyser.getByteTimeDomainData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = dataArray[i] - 128; 
        sum += Math.abs(v);
      }
      const avg = sum / dataArray.length;
      lastAvgAmp = avg;

      let db = 20 * Math.log10(avg + 1);
      if (!isFinite(db)) db = 0;
      lastDb = Math.max(0, Math.round(db));

      let volume = avg / 40;
      if (volume > 1) volume = 1;
      if (volume < 0) volume = 0;

      lastVolume = volume;
      return volume;
    }

    function resetGame() {
      player.x = 100;
      player.y = groundY;
      player.vy = 0;

      obstacles = [];
      spawnTimer = 0;
      spawnInterval = 1500;

      coins = [];
      coinSpawnTimer = 0;
      coinSpawnInterval = 1200;

      score = 0;
      coinsCollected = 0;

      jumpCount = 0;
      wasOverThreshold = false;

      lastVolume = 0;
      lastDb = 0;

      gameRunning = true;
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function spawnObstacle() {
      const height = 60 + Math.random() * 60;
      const width = 40 + Math.random() * 20;
      obstacles.push({
        x: canvas.width,
        y: groundY + (player.h - height),
        w: width,
        h: height,
        passed: false
      });
    }

    function spawnCoin() {
      const r = 14;
      const minY = 140;
      const maxY = groundY - 40;
      const y = minY + Math.random() * (maxY - minY);

      coins.push({
        x: canvas.width,
        y: y,
        r: r,
        collected: false
      });
    }

    function isColliding(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    function rectCircleColliding(rect, circle) {
      const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
      const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));
      const dx = circle.x - closestX;
      const dy = circle.y - closestY;
      return (dx * dx + dy * dy) < (circle.r * circle.r);
    }

    function update(delta) {
      const volume = getVolume();

      const onGround = (player.y >= groundY);
      if (onGround) {
        jumpCount = 0;
      }

      // 2ë‹¨ ì í”„: threshold ë„˜ëŠ” ìˆœê°„ë§ˆë‹¤ 1ë²ˆ
      if (volume > jumpThreshold) {
        if (!wasOverThreshold && jumpCount < maxJumpCount) {
          const baseJump = 7;
          const extraJump = volume * 10;
          player.vy = -(baseJump + extraJump);
          jumpCount++;
        }
        wasOverThreshold = true;
      } else {
        wasOverThreshold = false;
      }

      // ê¸°ë³¸ ì¤‘ë ¥
      player.vy += gravity;

      // ë–¨ì–´ì§€ëŠ” ì¤‘ + ì†Œë¦¬ ìˆì„ ë•Œë§Œ ë‚™í•˜ ì†ë„ ê°ì†Œ
      if (volume > 0.15 && player.vy > 0) {
        const slowFactor = 0.6;
        player.vy *= slowFactor;
      }

      // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
      player.y += player.vy;

      // ì²œì¥ ì œí•œ
      const ceilingY = 40;
      if (player.y < ceilingY) {
        player.y = ceilingY;
        if (player.vy < 0) player.vy = 0;
      }

      // ë°”ë‹¥
      if (player.y > groundY) {
        player.y = groundY;
        player.vy = 0;
      }

      // ì¥ì• ë¬¼ ìƒì„±
      spawnTimer += delta;
      if (spawnTimer > spawnInterval) {
        spawnObstacle();
        spawnTimer = 0;
        if (spawnInterval > 800) spawnInterval -= 30;
      }

      // ì½”ì¸ ìƒì„±
      coinSpawnTimer += delta;
      if (coinSpawnTimer > coinSpawnInterval) {
        spawnCoin();
        coinSpawnTimer = 0;
        if (coinSpawnInterval > 700) coinSpawnInterval -= 20;
      }

      // ì¥ì• ë¬¼ ì´ë™/ì¶©ëŒ
      for (let obs of obstacles) {
        obs.x -= obstacleSpeed;

        if (!obs.passed && obs.x + obs.w < player.x) {
          obs.passed = true;
          score++;
        }

        if (isColliding(player, obs)) {
          gameRunning = false;
        }
      }
      obstacles = obstacles.filter(o => o.x + o.w > 0);

      // ì½”ì¸ ì´ë™/íšë“
      for (let coin of coins) {
        coin.x -= obstacleSpeed;

        if (!coin.collected && rectCircleColliding(player, coin)) {
          coin.collected = true;
          score += 5;
          coinsCollected++;
        }
      }
      coins = coins.filter(c => !c.collected && c.x + c.r > 0);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ë°”ë‹¥
      ctx.fillStyle = "#555";
      ctx.fillRect(0, groundY + player.h, canvas.width, canvas.height - groundY - player.h);

      // í”Œë ˆì´ì–´ (ì´ë¯¸ì§€ ìˆìœ¼ë©´ ì´ë¯¸ì§€, ì•„ë‹ˆë©´ ì‚¬ê°í˜•)
      if (imgPlayer.complete && imgPlayer.naturalWidth !== 0) {
        ctx.drawImage(imgPlayer, player.x, player.y, player.w, player.h);
      } else {
        ctx.fillStyle = "#4caf50";
        ctx.fillRect(player.x, player.y, player.w, player.h);
      }

      // ì¥ì• ë¬¼
      for (let obs of obstacles) {
        if (imgObstacle.complete && imgObstacle.naturalWidth !== 0) {
          ctx.drawImage(imgObstacle, obs.x, obs.y, obs.w, obs.h);
        } else {
          ctx.fillStyle = "#f44336";
          ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
        }
      }

      // ì½”ì¸
      for (let coin of coins) {
        if (imgCoin.complete && imgCoin.naturalWidth !== 0) {
          const size = coin.r * 2;
          ctx.drawImage(imgCoin, coin.x - coin.r, coin.y - coin.r, size, size);
        } else {
          ctx.fillStyle = "#ffeb3b";
          ctx.beginPath();
          ctx.arc(coin.x, coin.y, coin.r, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // ì ìˆ˜
      ctx.fillStyle = "#fff";
      ctx.font = "20px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText("Score: " + score, 10, 30);
      ctx.fillText("Coins: " + coinsCollected, 10, 55);

      // ë³¼ë¥¨ ë°”
      const volume = lastVolume;
      const barWidth = 200;
      const barHeight = 10;
      ctx.font = "12px sans-serif";
      ctx.fillText("Volume", 10, 80);
      ctx.fillStyle = "#888";
      ctx.fillRect(10, 90, barWidth, barHeight);
      ctx.fillStyle = "#00e5ff";
      ctx.fillRect(10, 90, barWidth * volume, barHeight);

      // dB
      ctx.fillStyle = "#fff";
      ctx.font = "12px sans-serif";
      ctx.fillText("dB(ìƒëŒ€ê°’): " + lastDb, 10, 120);

      if (!gameRunning) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "32px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Game Over!", canvas.width / 2, canvas.height / 2 - 20);
        ctx.font = "20px sans-serif";
        ctx.fillText(
          "Score: " + score + "   (Coins: " + coinsCollected + ")",
          canvas.width / 2,
          canvas.height / 2 + 10
        );
        ctx.fillText("ë²„íŠ¼ì„ ëˆŒëŸ¬ ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”.", canvas.width / 2, canvas.height / 2 + 40);
        ctx.textAlign = "left";
      }
    }

    function gameLoop(timestamp) {
      if (!gameRunning) {
        draw();
        return;
      }
      const delta = timestamp - lastTime;
      lastTime = timestamp;

      update(delta);
      draw();

      requestAnimationFrame(gameLoop);
    }

    startBtn.addEventListener("click", async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        initAudio(stream);
        resetGame();
      } catch (err) {
        alert("ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì•¼ ê²Œì„ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\në¸Œë¼ìš°ì € ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.");
        console.error(err);
      }
    });
  </script>
</body>
</html>
