<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì†Œë¦¬ ì í”„ ì¥ì• ë¬¼ ê²Œì„</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #fff;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
    }
    #gameCanvas {
      background: #333;
      border: 2px solid #555;
      margin-top: 10px;
    }
    #info {
      margin-top: 10px;
      text-align: center;
      font-size: 14px;
      line-height: 1.5;
    }
    button {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h2>ì†Œë¦¬ë¡œ ì í”„í•˜ëŠ” ì¥ì• ë¬¼ ê²Œì„ (ì´ë¯¸ì§€ ë²„ì „)</h2>
  <button id="startBtn">ë§ˆì´í¬ í—ˆìš© í›„ ê²Œì„ ì‹œì‘</button>
  <canvas id="gameCanvas" width="800" height="400"></canvas>

  <div id="info">
    ğŸ”Š ë§ˆì´í¬ì— ëŒ€ê³  ì†Œë¦¬ë¥¼ ë‚´ë©´ ì í”„í•©ë‹ˆë‹¤. (2ë‹¨ ì í”„ ê°€ëŠ¥!)<br>
    ìºë¦­í„°/ì¥ì• ë¬¼/ì½”ì¸ì€ íˆ¬ëª… ë°°ê²½ PNG ì´ë¯¸ì§€ë¡œ í‘œì‹œë©ë‹ˆë‹¤.<br>
    dB(ìƒëŒ€ê°’)ëŠ” ì‹¤ì œ ë¬¼ë¦¬ ë°ì‹œë²¨ì´ ì•„ë‹Œ, ê²Œì„ìš© í‘œì‹œê°’ì…ë‹ˆë‹¤.
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const startBtn = document.getElementById("startBtn");

    // --------- ì´ë¯¸ì§€ ë¡œë”© ---------
    const imgPlayer = new Image();
    const imgObstacle = new Image();
    const imgCoin = new Image();

    // â–¶ ì—¬ê¸° íŒŒì¼ ì´ë¦„ì„ ë„¤ê°€ ì €ì¥í•œ íŒŒì¼ëª…ìœ¼ë¡œ ë°”ê¿”ì¤˜
    imgPlayer.src   = "player.png";    // ì•µê·¸ë¦¬ë²„ë“œ ëŠë‚Œ ìºë¦­í„°
    imgObstacle.src = "obstacle.png";  // ê°€ì‹œ/ìƒì ë“±
    imgCoin.src     = "coin.png";      // ë…¸ë€ ì½”ì¸

    // ì˜¤ë””ì˜¤ ê´€ë ¨ ë³€ìˆ˜
    let audioContext, analyser, dataArray;
    let micReady = false;

    // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
    const groundY = 320; // ë°”ë‹¥ y (í”Œë ˆì´ì–´ ê¸°ì¤€)
    const gravity = 0.6;
    const obstacleSpeed = 4.5;

    let obstacles = [];
    let spawnTimer = 0;
    let spawnInterval = 1500; // ms

    let coins = [];
    let coinSpawnTimer = 0;
    let coinSpawnInterval = 1200; // ms

    let lastTime = 0;
    let gameRunning = false;
    let score = 0;
    let coinsCollected = 0;

    // ì í”„ ê´€ë ¨ ë³€ìˆ˜ (2ë‹¨ ì í”„)
    let jumpCount = 0;
    const maxJumpCount = 2;
    const jumpThreshold = 0.25;
    let wasOverThreshold = false;

    // ë³¼ë¥¨/ë°ì‹œë²¨ í‘œì‹œìš©
    let lastAvgAmp = 0;
    let lastDb = 0;
    let lastVolume = 0;

    const player = {
      x: 100,
      y: groundY,
      w: 48,  // ì´ë¯¸ì§€ í¬ê¸°ì— ë§ê²Œ ì‚´ì§ í‚¤ì›€
      h: 48,
      vy: 0
    };

    function initAudio(stream) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      const bufferLength = analyser.fftSize;
      dataArray = new Uint8Array(bufferLength);

      source.connect(analyser);
      micReady = true;
    }

    function getVolume() {
      if (!micReady) return 0;

      analyser.getByteTimeDomainData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = dataArray[i] - 128; 
        sum += Math.abs(v);
      }
      const avg = sum / dataArray.length;
      lastAvgAmp = avg;

      let db = 20 * Math.log10(avg + 1);
      if (!isFinite(db)) db = 0;
      lastDb = Math.max(0, Math.round(db));

      let volume = avg / 40;
      if (volume > 1) volume = 1;
      if (volume < 0) volume = 0;

      lastVolume = volume;
      return volume;
    }

    function resetGame() {
      player.x = 100;
      player.y = groundY;
      player.vy = 0;

      obstacles = [];
      spawnTimer = 0;
      spawnInterval = 1500;

      coins = [];
      coinSpawnTimer = 0;
      coinSpawnInterval = 1200;

      score = 0;
      coinsCollected = 0;

      jumpCount = 0;
      wasOverThreshold = false;

      lastVolume = 0;
      lastDb = 0;

      gameRunning = true;
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function spawnObstacle() {
      const height = 60 + Math.random() * 60;
      const width = 40 + Math.random() * 20;
      obstacles.push({
        x: canvas.width,
        y: groundY + (player.h - height),
        w: width,
        h: height,
        passed: false
      });
    }

    function spawnCoin() {
      const r = 14;
      const minY = 140;
      const maxY = groundY - 40;
      const y = minY + Math.random() * (maxY - minY);

      coins.push({
        x: canvas.width,
        y: y,
        r: r,
        collected: false
      });
    }

    function isColliding(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    function rectCircleColliding(rect, circle) {
      const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
      const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));
      const dx = circle.x - closestX;
      const dy = circle.y - closestY;
      return (dx * dx + dy * dy) < (circle.r * circle.r);
    }

    function update(delta) {
      const volume = getVolume();

      const onGround = (player.y >= groundY);
      if (onGround) {
        jumpCount = 0;
      }

      // 2ë‹¨ ì í”„: threshold ë„˜ëŠ” ìˆœê°„ë§ˆë‹¤ 1ë²ˆ
      if (volume > jumpThreshold) {
        if (!wasOverThreshold && jumpCount < maxJumpCount) {
          const baseJump = 7;
          const extraJump = volume * 10;
          player.vy = -(baseJump + extraJump);
          jumpCount++;
        }
        wasOverThreshold = true;
      } else {
        wasOverThreshold = false;
      }

      // ê¸°ë³¸ ì¤‘ë ¥
      player.vy += gravity;

      // ë–¨ì–´ì§€ëŠ” ì¤‘ + ì†Œë¦¬ ìˆì„ ë•Œë§Œ ë‚™í•˜ ì†ë„ ê°ì†Œ
      if (volume > 0.15 && player.vy > 0) {
        const slowFactor = 0.6;
        player.vy *= slowFactor;
      }

      // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
      player.y += player.vy;

      // ì²œì¥ ì œí•œ
      const ceilingY = 40;
      if (player.y < ceilingY) {
        player.y = ceilingY;
        if (player.vy < 0) player.vy = 0;
      }

      // ë°”ë‹¥
      if (player.y > groundY) {
        player.y = groundY;
        player.vy = 0;
      }

      // ì¥ì• ë¬¼ ìƒì„±
      spawnTimer += delta;
      if (spawnTimer > spawnInterval) {
        spawnObstacle();
        spawnTimer = 0;
        if (spawnInterval > 800) spawnInterval -= 30;
      }

      // ì½”ì¸ ìƒì„±
      coinSpawnTimer += delta;
      if (coinSpawnTimer > coinSpawnInterval) {
        spawnCoin();
        coinSpawnTimer = 0;
        if (coinSpawnInterval > 700) coinSpawnInterval -= 20;
      }

      // ì¥ì• ë¬¼ ì´ë™/ì¶©ëŒ
      for (let obs of obstacles) {
        obs.x -= obstacleSpeed;

        if (!obs.passed && obs.x + obs.w < player.x) {
          obs.passed = true;
          score++;
        }

        if (isColliding(pla
