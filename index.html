<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì†Œë¦¬ ì í”„ ì¥ì• ë¬¼ ê²Œì„</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #fff;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
    }
    #gameCanvas {
      background: #333;
      border: 2px solid #555;
      margin-top: 10px;
    }
    #info {
      margin-top: 10px;
      text-align: center;
      font-size: 14px;
      line-height: 1.5;
    }
    button {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h2>ì†Œë¦¬ë¡œ ì í”„í•˜ëŠ” ì¥ì• ë¬¼ ê²Œì„ (2ë‹¨ ì í”„ + ì½”ì¸ + ì²´ê³µ ê°•í™”)</h2>
  <button id="startBtn">ë§ˆì´í¬ í—ˆìš© í›„ ê²Œì„ ì‹œì‘</button>
  <canvas id="gameCanvas" width="800" height="400"></canvas>

  <div id="info">
    ğŸ”Š ë§ˆì´í¬ì— ëŒ€ê³  ì†Œë¦¬ë¥¼ ë‚´ë©´ ì í”„í•©ë‹ˆë‹¤. (2ë‹¨ ì í”„ ê°€ëŠ¥!)<br>
    ì‘ì€ ì†Œë¦¬ â†’ ë‚®ê²Œ / í° ì†Œë¦¬ â†’ ë†’ê²Œ ì í”„í•©ë‹ˆë‹¤.<br>
    ì†Œë¦¬ê°€ ë‚˜ëŠ” ë™ì•ˆì—ëŠ” ê³µì¤‘ì—ì„œ ì²œì²œíˆ ë–¨ì–´ì ¸ìš”. (ì²´ê³µ íš¨ê³¼â†‘)<br>
    ë…¸ë€ ì½”ì¸ì„ ë¨¹ìœ¼ë©´ ì ìˆ˜ê°€ ì¶”ê°€ë©ë‹ˆë‹¤.<br>
    dB(ìƒëŒ€ê°’)ëŠ” ì‹¤ì œ ë¬¼ë¦¬ ë°ì‹œë²¨ì´ ì•„ë‹Œ, ê²Œì„ìš© í‘œì‹œê°’ì…ë‹ˆë‹¤.
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const startBtn = document.getElementById("startBtn");

    // ì˜¤ë””ì˜¤ ê´€ë ¨ ë³€ìˆ˜
    let audioContext, analyser, dataArray;
    let micReady = false;

    // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
    const groundY = 320; // ë°”ë‹¥ ë†’ì´ (í”Œë ˆì´ì–´ y ê¸°ì¤€)
    const gravity = 0.6;
    const obstacleSpeed = 4.5;

    let obstacles = [];
    let spawnTimer = 0;
    let spawnInterval = 1500; // ms

    let coins = [];
    let coinSpawnTimer = 0;
    let coinSpawnInterval = 1200; // ms

    let lastTime = 0;
    let gameRunning = false;
    let score = 0;
    let coinsCollected = 0;

    // ì í”„ ê´€ë ¨ ë³€ìˆ˜ (2ë‹¨ ì í”„)
    let jumpCount = 0;
    const maxJumpCount = 2;
    const jumpThreshold = 0.25; // ì´ ì´ìƒ ì†Œë¦¬ ë‚  ë•Œ ì í”„
    let wasOverThreshold = false;

    // ë³¼ë¥¨/ë°ì‹œë²¨ í‘œì‹œìš©
    let lastAvgAmp = 0;
    let lastDb = 0;       // ìƒëŒ€ê°’ ë°ì‹œë²¨
    let lastVolume = 0;   // 0~1 ì •ê·œí™”ëœ ë³¼ë¥¨

    const player = {
      x: 100,
      y: groundY,
      w: 40,
      h: 40,
      vy: 0
    };

    function initAudio(stream) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048;
      const bufferLength = analyser.fftSize;
      dataArray = new Uint8Array(bufferLength);

      source.connect(analyser);
      micReady = true;
    }

    function getVolume() {
      if (!micReady) return 0;

      analyser.getByteTimeDomainData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = dataArray[i] - 128; // ë¬´ìŒ ê¸°ì¤€
        sum += Math.abs(v);
      }
      const avg = sum / dataArray.length; // í‰ê·  ì§„í­ (0~ëŒ€ëµ 50 ê·¼ì²˜)
      lastAvgAmp = avg;

      // ê²Œì„ìš© ë°ì‹œë²¨(ìƒëŒ€ê°’) ê³„ì‚°
      let db = 20 * Math.log10(avg + 1); // +1ë¡œ 0 ë°©ì§€
      if (!isFinite(db)) db = 0;
      lastDb = Math.max(0, Math.round(db));

      // 0~1 ì •ë„ë¡œ ì •ê·œí™”í•œ ë³¼ë¥¨
      let volume = avg / 40; // ëŒ€ëµ 0~1 ë²”ìœ„
      if (volume > 1) volume = 1;
      if (volume < 0) volume = 0;

      lastVolume = volume;
      return volume;
    }

    function resetGame() {
      player.x = 100;
      player.y = groundY;
      player.vy = 0;

      obstacles = [];
      spawnTimer = 0;
      spawnInterval = 1500;

      coins = [];
      coinSpawnTimer = 0;
      coinSpawnInterval = 1200;

      score = 0;
      coinsCollected = 0;

      jumpCount = 0;
      wasOverThreshold = false;

      lastVolume = 0;
      lastDb = 0;

      gameRunning = true;
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function spawnObstacle() {
      const height = 60 + Math.random() * 60;
      const width = 30 + Math.random() * 20;
      obstacles.push({
        x: canvas.width,
        y: groundY + (player.h - height),
        w: width,
        h: height,
        passed: false
      });
    }

    function spawnCoin() {
      // ì½”ì¸ì€ ê³µì¤‘ì— ë–  ìˆëŠ” ëŠë‚Œìœ¼ë¡œ ìƒì„±
      const r = 10 + Math.random() * 8;
      const minY = 140;
      const maxY = groundY - 40;
      const y = minY + Math.random() * (maxY - minY);

      coins.push({
        x: canvas.width,
        y: y,
        r: r,
        collected: false
      });
    }

    function isColliding(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    function rectCircleColliding(rect, circle) {
      // ì§ì‚¬ê°í˜•-ì› ì¶©ëŒ (ì½”ì¸ vs í”Œë ˆì´ì–´)
      const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
      const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));
      const dx = circle.x - closestX;
      const dy = circle.y - closestY;
      return (dx * dx + dy * dy) < (circle.r * circle.r);
    }

    function doJump(volume) {
      const baseJump = 10;
      const extraJump = volume * 18;
      player.vy = -(baseJump + extraJump);
    }

    function update(delta) {
      const volume = getVolume();

      // ë°”ë‹¥ì— ë‹¿ìœ¼ë©´ ì í”„ íšŸìˆ˜ ì´ˆê¸°í™”
      const onGround = (player.y >= groundY);
      if (onGround) {
        jumpCount = 0;
      }

      // 2ë‹¨ ì í”„: ì†Œë¦¬ê°€ thresholdë¥¼ ë„˜ëŠ” 'ìˆœê°„'ë§ˆë‹¤ ì í”„ 1ë²ˆ ì‚¬ìš©
      if (volume > jumpThreshold) {
        if (!wasOverThreshold && jumpCount < maxJumpCount) {
          doJump(volume);
          jumpCount++;
        }
        wasOverThreshold = true;
      } else {
        wasOverThreshold = false;
      }

      // âœ” ë‚™í•˜ ì†ë„ í¬ê²Œ ëŠë ¤ì§€ëŠ” íš¨ê³¼ (ì†Œë¦¬ ìˆì„ ë•Œ ì²´ê³µ ê°•í™”)
      if (volume > 0.15) {
        // ì†Œë¦¬ê°€ í´ìˆ˜ë¡ ë” ì˜¤ë˜ ë‘¥ë‘¥ ë–  ìˆëŠ” ëŠë‚Œ
        const antiGravity = volume * 1.0;  // ìƒìŠ¹ë ¥(ê°’ í´ìˆ˜ë¡ ìœ„ë¡œ ë²„í…¨ì¤Œ)
        player.vy += gravity * 0.15;      // ì¤‘ë ¥ 85% ê°ì†Œ
        player.vy -= antiGravity;         // ìœ„ë¡œ ì‚´ì§ ëŒì–´ì˜¬ë¦¼
      } else {
        // í‰ì†Œ ì¤‘ë ¥
        player.vy += gravity;
      }

      // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
      player.y += player.vy;

      // ë°”ë‹¥ ì¶©ëŒ ì²˜ë¦¬
      if (player.y > groundY) {
        player.y = groundY;
        player.vy = 0;
      }

      // ì¥ì• ë¬¼ ìƒì„± íƒ€ì´ë¨¸
      spawnTimer += delta;
      if (spawnTimer > spawnInterval) {
        spawnObstacle();
        spawnTimer = 0;
        // ë‚œì´ë„ ì ì§„ ì¦ê°€
        if (spawnInterval > 800) {
          spawnInterval -= 30;
        }
      }

      // ì½”ì¸ ìƒì„± íƒ€ì´ë¨¸
      coinSpawnTimer += delta;
      if (coinSpawnTimer > coinSpawnInterval) {
        spawnCoin();
        coinSpawnTimer = 0;
        if (coinSpawnInterval > 700) {
          coinSpawnInterval -= 20;
        }
      }

      // ì¥ì• ë¬¼ ì´ë™ ë° ì¶©ëŒ ì²´í¬
      for (let obs of obstacles) {
        obs.x -= obstacleSpeed;

        // ì ìˆ˜: í”Œë ˆì´ì–´ ë’¤ë¡œ ì§€ë‚˜ê°€ë©´ +1
        if (!obs.passed && obs.x + obs.w < player.x) {
          obs.passed = true;
          score++;
        }

        // ì¶©ëŒ ì²´í¬ (í”Œë ˆì´ì–´ vs ì¥ì• ë¬¼)
        if (isColliding(player, obs)) {
          gameRunning = false;
        }
      }

      // í™”ë©´ ë°– ì¥ì• ë¬¼ ì œê±°
      obstacles = obstacles.filter(o => o.x + o.w > 0);

      // ì½”ì¸ ì´ë™ ë° ë¨¹ê¸° íŒì •
      for (let coin of coins) {
        coin.x -= obstacleSpeed;

        if (!coin.collected && rectCircleColliding(player, coin)) {
          coin.collected = true;
          score += 5;
          coinsCollected++;
        }
      }

      // í™”ë©´ ë°–ì´ê±°ë‚˜ ë¨¹íŒ ì½”ì¸ ì œê±°
      coins = coins.filter(c => !c.collected && c.x + c.r > 0);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ë°”ë‹¥
      ctx.fillStyle = "#555";
      ctx.fillRect(0, groundY + player.h, canvas.width, canvas.height - groundY - player.h);

      // í”Œë ˆì´ì–´
      ctx.fillStyle = "#4caf50";
      ctx.fillRect(player.x, player.y, player.w, player.h);

      // ì¥ì• ë¬¼
      ctx.fillStyle = "#f44336";
      for (let obs of obstacles) {
        ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
      }

      // ì½”ì¸ (ë…¸ë€ ì›)
      ctx.fillStyle = "#ffeb3b";
      for (let coin of coins) {
        ctx.beginPath();
        ctx.arc(coin.x, coin.y, coin.r, 0, Math.PI * 2);
        ctx.fill();
      }

      // ì ìˆ˜ & ì½”ì¸ ìˆ˜
      ctx.fillStyle = "#fff";
      ctx.font = "20px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText("Score: " + score, 10, 30);
      ctx.fillText("Coins: " + coinsCollected, 10, 55);

      // í˜„ì¬ ë³¼ë¥¨ ë°” í‘œì‹œ (ë§ˆì§€ë§‰ ì¸¡ì •ê°’ ì‚¬ìš©)
      const volume = lastVolume;
      const barWidth = 200;
      const barHeight = 10;

      ctx.font = "12px sans-serif";
      ctx.fillText("Volume", 10, 80);
      ctx.fillStyle = "#888";
      ctx.fillRect(10, 90, barWidth, barHeight);
      ctx.fillStyle = "#00e5ff";
      ctx.fillRect(10, 90, barWidth * volume, barHeight);

      // ë°ì‹œë²¨(ìƒëŒ€ê°’) í‘œì‹œ
      ctx.fillStyle = "#fff";
      ctx.font = "12px sans-serif";
      ctx.fillText("dB(ìƒëŒ€ê°’): " + lastDb, 10, 120);

      if (!gameRunning) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "32px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Game Over!", canvas.width / 2, canvas.height / 2 - 20);
        ctx.font = "20px sans-serif";
        ctx.fillText(
          "Score: " + score + "   (Coins: " + coinsCollected + ")",
          canvas.width / 2,
          canvas.height / 2 + 10
        );
        ctx.fillText("ë²„íŠ¼ì„ ëˆŒëŸ¬ ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”.", canvas.width / 2, canvas.height / 2 + 40);
        ctx.textAlign = "left";
      }
    }

    function gameLoop(timestamp) {
      if (!gameRunning) {
        draw();
        return;
      }
      const delta = timestamp - lastTime;
      lastTime = timestamp;

      update(delta);
      draw();

      requestAnimationFrame(gameLoop);
    }

    startBtn.addEventListener("click", async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        initAudio(stream);
        resetGame();
      } catch (err) {
        alert("ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì•¼ ê²Œì„ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\në¸Œë¼ìš°ì € ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.");
        console.error(err);
      }
    });
  </script>
</body>
</html>
